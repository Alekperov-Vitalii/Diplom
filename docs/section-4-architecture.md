# 4 ПРОЕКТУВАННЯ АРХІТЕКТУРИ ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ

У цьому розділі розглядається процес проектування архітектури програмного забезпечення для веб-системи моніторингу та керування охолодженням GPU-кластера. Архітектурні рішення базуються на результатах моделювання, проведеного в попередньому розділі, та аналізі сучасних типових архітектур для систем реального часу та IoT-моніторингу. Метою проектування є створення ефективної, масштабованої та надійної архітектури, яка забезпечить стабільну роботу системи та її подальший розвиток.

## 4.1 Вибір архітектурного підходу

Для розробки веб-системи моніторингу та керування охолодженням GPU-кластера обрано багаторівневу клієнт-серверну архітектуру з розділенням відповідальності між компонентами. Цей підхід передбачає чітке розмежування рівнів представлення, бізнес-логіки та зберігання даних, що забезпечує гнучкість, спрощує масштабування та полегшує обслуговування системи.

Обґрунтування вибору багаторівневої архітектури ґрунтується на наступних факторах:

1. **Розділення відповідальності**: кожен рівень системи відповідає за конкретну функціональність, що спрощує розробку, тестування та підтримку коду.

2. **Масштабованість**: незалежні компоненти можуть масштабуватися окремо залежно від навантаження, що особливо важливо для систем моніторингу з високою частотою оновлення даних.

3. **Надійність**: ізоляція компонентів дозволяє локалізувати збої та забезпечити продовження роботи інших частин системи при відмові окремих компонентів.

4. **Технологічна гнучкість**: різні рівні можуть використовувати найбільш підходящі технології для своїх задач (Next.js для веб-інтерфейсу, FastAPI для серверної логіки, InfluxDB для часових рядів).

Архітектура системи реалізує патерн "Fog Computing", де обробка даних відбувається ближче до джерела (fog-сервер), а не виключно в хмарі, що зменшує затримки та навантаження на мережу. Це особливо важливо для систем реального часу, де критична швидкість реакції на зміни стану обладнання.

## 4.2 Опис компонентів системи

Архітектура веб-системи моніторингу складається з наступних основних компонентів:

### 4.2.1 Рівень представлення (Presentation Layer)

**Веб-інтерфейс (Next.js Application)** — клієнтська частина системи, реалізована на базі фреймворку Next.js 16.0.6 з використанням React 19.2.0 та TypeScript. Веб-інтерфейс відповідає за:

- Візуалізацію поточного стану системи (температури GPU, стан вентиляторів, активні алерти)
- Відображення історичних даних у вигляді графіків та таблиць
- Надання інтерфейсу для ручного керування системою охолодження
- Обробку взаємодії користувача та формування запитів до серверної частини

Архітектура веб-інтерфейсу організована за принципами App Router Next.js, що забезпечує файлову маршрутизацію та серверні та клієнтські компоненти. Структура включає:

- **Сторінки (Pages)**: головна сторінка Dashboard (`app/page.tsx`), сторінка історії (`app/history/page.tsx`), сторінка ручного керування (`app/control/page.tsx`)
- **Компоненти (Components)**: переіспользувані UI-компоненти, такі як `FanCard` для відображення статистики вентиляторів
- **Бібліотека (Library)**: модуль `lib/api.ts`, що інкапсулює всю логіку взаємодії з API fog-сервера

### 4.2.2 Рівень бізнес-логіки (Business Logic Layer)

**Fog-сервер (FastAPI Application)** — серверна частина системи, реалізована на базі FastAPI (Python). Fog-сервер виконує наступні функції:

- **Прийом телеметрії**: отримання даних від апаратного рівня (ESP32 або емулятора) через HTTP POST запити на ендпоінт `/api/v1/telemetry`
- **Збереження даних**: запис телеметрії в InfluxDB для подальшого аналізу та візуалізації
- **Алгоритм керування**: реалізація каскадного алгоритму автоматичного керування охолодженням на основі температур GPU та приміщення
- **Управління режимами**: обробка перемикання між автоматичним та ручним режимами роботи системи
- **Система алертів**: виявлення критичних та попереджувальних ситуацій при перевищенні порогових значень температур
- **RESTful API**: надання стандартизованого API для веб-інтерфейсу з підтримкою CORS для крос-доменних запитів

Fog-сервер реалізує патерн "API Gateway", централізуючи всі запити від клієнтів та координуючи взаємодію з базою даних та апаратним рівнем.

### 4.2.3 Рівень зберігання даних (Data Layer)

**InfluxDB** — часовісна база даних, оптимізована для зберігання та обробки даних часових рядів. InfluxDB відповідає за:

- **Зберігання телеметрії**: запис температур GPU, стану вентиляторів (PWM, RPM), температури приміщення з високою частотою (кожні 30 секунд)
- **Зберігання алертів**: історія критичних подій та попереджень для аналізу та діагностики
- **Ефективні запити**: оптимізовані запити для отримання історичних даних за різні періоди (1, 3, 6, 24 години)
- **Агрегація даних**: підтримка функцій агрегації (середнє, мінімум, максимум) для статистичного аналізу

Використання InfluxDB обґрунтовано специфікою даних системи моніторингу: високою частотою записів, необхідністю ефективного запиту за часовими діапазонами та оптимізацією для роботи з часовими рядами.

### 4.2.4 Апаратний рівень (Hardware Layer)

**ESP32 або Емулятор** — джерело телеметрії, що відповідає за:

- **Збір даних**: читання температур з датчиків DS18B20, підключених до GPU та приміщення
- **Моніторинг вентиляторів**: зчитування поточних значень PWM та RPM з кожного вентилятора
- **Відправка телеметрії**: періодична передача даних на fog-сервер через HTTP POST запити
- **Виконання команд**: отримання та застосування команд керування вентиляторами від fog-сервера

У режимі розробки та тестування використовується емулятор, що симулює поведінку реального апаратного обладнання з налаштовуваними параметрами нагрівання та охолодження.

## 4.3 Взаємодія компонентів та протоколи обміну даними

Взаємодія між компонентами системи реалізована через стандартизовані протоколи та API, що забезпечує сумісність, надійність та легкість інтеграції.

### 4.3.1 Потік даних від апаратного рівня до веб-інтерфейсу

Дані проходять наступний шлях обробки:

1. **ESP32/Емулятор → Fog-сервер**: апаратний рівень надсилає телеметрію через HTTP POST запит на ендпоінт `/api/v1/telemetry` з інтервалом 30 секунд. Пейлоад запиту містить JSON-об'єкт з температурами всіх GPU, температурою приміщення, станом вентиляторів та timestamp.

2. **Fog-сервер → InfluxDB**: отримавши телеметрію, fog-сервер миттєво зберігає її в InfluxDB через InfluxDB Client API. Кожна точка даних записується як measurement з відповідними полями (fields) та тегами (tags) для ефективного запитування.

3. **Fog-сервер → Алгоритм керування**: у автоматичному режимі fog-сервер виконує каскадний алгоритм обчислення команд керування вентиляторами на основі поточних температур. Обчислені команди зберігаються та повертаються апаратному рівню у відповіді на запит телеметрії.

4. **Fog-сервер → Веб-інтерфейс**: веб-інтерфейс періодично (кожні 5 секунд) виконує запити до RESTful API fog-сервера для отримання поточного стану системи, статистики вентиляторів та режиму роботи.

### 4.3.2 RESTful API для веб-інтерфейсу

Fog-сервер надає наступні ключові ендпоінти:

- `GET /api/v1/current-state` — отримання поточного стану системи (температури GPU, активні алерти, timestamp)
- `GET /api/v1/history?hours=N` — історія температур за вказаний період (1, 3, 6 або 24 години)
- `GET /api/v1/fan-history?hours=N` — історія роботи вентиляторів (PWM, RPM) за вказаний період
- `GET /api/v1/fan-statistics` — статистика роботи вентиляторів за останню годину (середній, мінімальний, максимальний PWM, час роботи на високих оборотах)
- `GET /api/v1/system-mode` — поточний режим роботи (автоматичний/ручний) з інформацією про останню зміну
- `POST /api/v1/system-mode` — зміна режиму роботи системи (автоматичний/ручний)
- `POST /api/v1/fan-control/manual` — встановлення ручного керування вентиляторами з масивом команд (fan_id, pwm_duty)
- `GET /health` — перевірка доступності fog-сервера (health check)

Всі запити повертають дані у форматі JSON з чітко визначеною структурою, що забезпечує типобезпеку на рівні TypeScript у веб-інтерфейсі.

### 4.3.3 Механізм оновлення даних (Polling)

Для забезпечення актуальності даних у веб-інтерфейсі реалізовано механізм періодичного опитування (polling) fog-сервера з інтервалом 5 секунд. Цей підхід обрано замість WebSocket з наступних причин:

1. **Простота реалізації**: polling не вимагає підтримки постійного з'єднання та складнішої обробки подій на сервері
2. **Надійність**: HTTP-запити легше обробляти при збоях мережі, вони автоматично повторюються браузером
3. **Масштабованість**: для системи з одним або кількома одночасними користувачами polling не створює значного навантаження
4. **Сумісність**: працює через стандартні HTTP-протоколи без додаткових налаштувань

Механізм polling реалізовано через React хук `useEffect` з `setInterval`, що виконує паралельні запити до кількох ендпоінтів за допомогою `Promise.all()` для мінімізації затримки оновлення інтерфейсу.

## 4.4 Обґрунтування вибору технологій

Вибір технологічного стеку для реалізації системи базується на аналізі вимог до продуктивності, масштабованості, підтримуваності та сучасності технологій.

### 4.4.1 Веб-інтерфейс: Next.js + React + TypeScript

**Next.js 16.0.6** обрано як фреймворк для веб-інтерфейсу з наступних причин:

- **Server-Side Rendering (SSR) та Static Site Generation (SSG)**: забезпечує швидке завантаження сторінок та кращу SEO-оптимізацію
- **App Router**: сучасний підхід до маршрутизації з файловою структурою, що спрощує організацію коду
- **Оптимізація продуктивності**: автоматична оптимізація зображень, шрифтів та JavaScript-бандлів
- **API Routes**: можливість створення серверних ендпоінтів без окремого backend-сервера (не використовується в поточній реалізації, але забезпечує гнучкість)

**React 19.2.0** використовується як бібліотека для побудови користувацького інтерфейсу:

- **Компонентна архітектура**: дозволяє створювати переіспользувані UI-компоненти
- **Реактивність**: автоматичне оновлення інтерфейсу при зміні стану
- **Велика екосистема**: багата бібліотека готових компонентів та інструментів

**TypeScript** забезпечує типобезпеку та покращує підтримуваність коду:

- **Статична типізація**: виявлення помилок на етапі компіляції
- **Автодоповнення**: покращена продуктивність розробки завдяки IDE-підтримці
- **Рефакторинг**: безпечне перейменування та зміна структури коду

### 4.4.2 Серверна частина: FastAPI (Python)

**FastAPI** обрано для реалізації fog-сервера з наступних причин:

- **Висока продуктивність**: асинхронна обробка запитів завдяки використанню ASGI (Asynchronous Server Gateway Interface)
- **Автоматична документація**: генерація OpenAPI/Swagger документації з анотацій типів
- **Валідація даних**: автоматична валідація вхідних та вихідних даних через Pydantic моделі
- **Сучасний синтаксис Python**: використання type hints та async/await для читабельного та підтримуваного коду
- **Широка екосистема**: інтеграція з InfluxDB, підтримка WebSocket для майбутніх розширень

### 4.4.3 База даних: InfluxDB

**InfluxDB** обрано як часовісну базу даних з наступних причин:

- **Оптимізація для часових рядів**: спеціалізована структура даних для ефективного зберігання та запитування часових даних
- **Висока продуктивність**: швидкі запити за часовими діапазонами навіть при великих обсягах даних
- **Мова запитів Flux**: потужна мова для аналізу та агрегації даних часових рядів
- **Масштабованість**: підтримка кластеризації для обробки великих обсягів даних
- **Retention Policies**: автоматичне видалення старих даних для оптимізації використання дискового простору

### 4.4.4 Стилізація: Tailwind CSS

**Tailwind CSS** використовується для стилізації веб-інтерфейсу:

- **Utility-first підхід**: швидка розробка інтерфейсів без написання власного CSS
- **Адаптивність**: вбудована підтримка responsive design через модифікатори (sm:, md:, lg:)
- **Оптимізація**: автоматичне видалення невикористаних стилів при збірці
- **Консистентність**: стандартизована система кольорів, відстаней та типографіки

### 4.4.5 Візуалізація даних: Recharts

**Recharts** використовується для побудови графіків:

- **React-інтеграція**: нативна інтеграція з React компонентами
- **Гнучкість**: широкі можливості налаштування зовнішнього вигляду графіків
- **Продуктивність**: базується на D3.js, забезпечує плавну анімацію та інтерактивність
- **Типізація**: повна підтримка TypeScript

## 4.5 Діаграма розгортання (Deployment Diagram)

Діаграма розгортання відображає фізичне розташування компонентів системи та їх взаємодію. Архітектура розгортання включає наступні елементи:

### 4.5.1 Клієнтський рівень

**Веб-браузер користувача** — виконує веб-інтерфейс Next.js, який може бути розгорнутий у двох режимах:

- **Development режим**: локальний розробницький сервер на порту 3000, що виконує hot-reload для швидкої ітерації
- **Production режим**: статично згенеровані сторінки або серверний рендеринг на платформі розгортання (наприклад, Vercel, AWS, або власний сервер)

Веб-інтерфейс комунікує з fog-сервером через HTTP/HTTPS протокол, виконуючи RESTful API запити.

### 4.5.2 Серверний рівень

**Fog-сервер (FastAPI)** — розгортається як окремий процес або контейнер, що слухає на порту 8001. Сервер може бути розгорнутий:

- **Локально**: для розробки та тестування на локальній машині
- **На виділеному сервері**: для production середовища з підтримкою високої доступності
- **У контейнері Docker**: для спрощення розгортання та масштабування

Fog-сервер виконує роль API Gateway, обробляючи всі запити від веб-інтерфейсу та апаратного рівня, та координуючи взаємодію з базою даних.

### 4.5.3 Рівень зберігання даних

**InfluxDB** — розгортається як окремий сервіс бази даних, доступний через HTTP API на порту 8086. InfluxDB може бути розгорнута:

- **Локально**: для розробки та тестування
- **На виділеному сервері**: для production середовища з резервуванням та реплікацією
- **У контейнері Docker**: для спрощення управління та масштабування
- **InfluxDB Cloud**: хмарне рішення для автоматичного масштабування та управління

InfluxDB зберігає всі телеметричні дані, алерти та історію дій користувачів.

### 4.5.4 Апаратний рівень

**ESP32 або Емулятор** — джерело телеметрії, що може бути:

- **Реальне апаратне обладнання**: ESP32 мікроконтролер з підключеними датчиками температури та вентиляторами
- **Програмний емулятор**: для розробки та тестування без реального апаратного обладнання

Апаратний рівень періодично надсилає телеметрію на fog-сервер та отримує команди керування вентиляторами.

### 4.5.5 Мережева інфраструктура

Всі компоненти системи комунікують через локальну мережу або інтернет:

- **Веб-інтерфейс ↔ Fog-сервер**: HTTP/HTTPS з підтримкою CORS для крос-доменних запитів
- **Fog-сервер ↔ InfluxDB**: HTTP API з токеном автентифікації
- **ESP32/Емулятор ↔ Fog-сервер**: HTTP POST для телеметрії, HTTP GET для отримання команд

Для production середовища рекомендується використання HTTPS для захисту даних та автентифікації, а також налаштування firewall для обмеження доступу до критичних компонентів.

### 4.5.6 Можливі варіанти розгортання

Система підтримує різні варіанти розгортання залежно від вимог:

1. **Монолітне розгортання**: всі компоненти на одному сервері для малих систем або розробки
2. **Розподілене розгортання**: компоненти на окремих серверах для масштабування та високої доступності
3. **Контейнеризація**: використання Docker для спрощення розгортання та управління
4. **Оркестрація**: використання Kubernetes для автоматичного масштабування та управління контейнерами (для майбутніх розширень)

## 4.6 Забезпечення якості та безпеки архітектури

При проектуванні архітектури особлива увага приділяється забезпеченню якості, надійності та безпеки системи.

### 4.6.1 Обробка помилок та відмовостійкість

Архітектура системи включає механізми обробки помилок на різних рівнях:

- **Веб-інтерфейс**: обробка помилок мережевих запитів з відображенням зрозумілих повідомлень користувачу, health check для перевірки доступності fog-сервера
- **Fog-сервер**: валідація вхідних даних через Pydantic моделі, обробка винятків при роботі з InfluxDB, повернення структурованих помилок у форматі JSON
- **InfluxDB**: автоматичне резервування та реплікація даних для забезпечення надійності

### 4.6.2 Безпека

Архітектура включає наступні механізми безпеки:

- **CORS (Cross-Origin Resource Sharing)**: налаштування на fog-сервері для контролю доступу з різних доменів
- **Валідація даних**: перевірка всіх вхідних даних на рівні API для запобігання ін'єкціям та некоректним значенням
- **Автентифікація InfluxDB**: використання токенів для доступу до бази даних
- **HTTPS (рекомендовано для production)**: шифрування трафіку між компонентами для захисту даних

### 4.6.3 Масштабованість

Архітектура спроектована з урахуванням можливості масштабування:

- **Горизонтальне масштабування**: можливість додавання додаткових екземплярів fog-сервера за наявності балансувальника навантаження
- **Вертикальне масштабування**: можливість збільшення ресурсів (CPU, RAM) для окремих компонентів
- **Оптимізація запитів**: ефективні запити до InfluxDB з використанням індексів та retention policies для управління обсягом даних

### 4.6.4 Моніторинг та логування

Для забезпечення діагностики та моніторингу системи:

- **Логування**: структуровані логи на fog-сервері для відстеження обробки запитів та помилок
- **Health checks**: ендпоінт `/health` для перевірки доступності fog-сервера
- **Метрики**: можливість збору метрик продуктивності через InfluxDB для аналізу навантаження

## 4.7 Висновки

Розроблена архітектура веб-системи моніторингу та керування охолодженням GPU-кластера на основі багаторівневої клієнт-серверної моделі забезпечує гнучкість, масштабованість та надійність. Використання сучасних технологій (Next.js, FastAPI, InfluxDB) сприяє ефективній реалізації функціональних вимог та забезпеченню високої якості програмного забезпечення.

Архітектурні рішення базуються на принципах розділення відповідальності, що спрощує розробку, тестування та підтримку системи. Використання RESTful API забезпечує стандартизовану взаємодію між компонентами, а механізм polling надає прийнятний баланс між актуальністю даних та навантаженням на систему.

Діаграма розгортання наочно демонструє взаємодію між компонентами та їхнє розміщення, що полегшує подальше впровадження та обслуговування системи. Архітектура дозволяє легко адаптуватися до змінних вимог та умов експлуатації, забезпечуючи основу для подальшого розвитку та розширення функціональності системи.

